1. 面向对象的优点？
   - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 
   - 缺点：性能比面向过程低 

2. python 语言的特性

   1. 简单。python遵循"简单、优雅、明确"的设计哲学。
   2. 高级。python是一种高级语言，相对于c，牺牲了性能而提升了编程人员的效率。它使得程序员可以不用关注底层细节，而把精力全部放在编程上。
   3. 面向对象。python既支持面向过程，也支持面向对象。
   4. 可扩展。可以通过c、c++语言为python编写扩充模块。
   5. 免费和开源。python是FLOSS(自由/开放源码软件)之一，允许自由的发布软件的备份、阅读和修改其源代码、将其一部分自由地用于新的自由软件中。
   6. 解释型语言，边编译边执行。
   7. 跨平台。python能运行在不同的平台上。
   8. 丰富的库。python拥有许多功能丰富的库。
   9. 可嵌入性。python可以嵌入到c、c++中，为其提供脚本功能。

3. Linux系统批量修改文件的命令

   具体问题具体分析，批量修改哪方面

4. Linux下查看磁盘空间

   df：列出文件系统的整体磁盘使用量；

   du：评估文件系统的磁盘使用量（常用于评估目录所占容量）

   **df参数：**

   -a：列出所有的文件系统，包括系统特有的/proc等文件系统

   -k：以KB的容量显示各文件系统

   -m：以MB的容量显示各文件系统

   -h：以人们较易阅读的GB,MB,KB等格式自行显示

   -H：以M=1000K替代M=1024K的进位方式

   -T：连同该分区的文件系统名称（例如ext3）也列出

   -i：不用硬盘容量，而以inode的数量来显示

5. redis是单线程还是多线程

   单线程

6. django删除数据库一条记录

   数据对象.delete()

7. 归并排序

   https://blog.csdn.net/perfer258/article/details/81985349

   ```Python
   #递归计算，先拆分，再合并
   def sort(arr, low, high):
       if low < high:
           #无限拆分直到长度为1
           mid = (low + high) // 2
           sort(arr, low, mid)
           sort(arr, mid+1, high)
           #开始长度为1，之后开始相邻序列进行合并
           merge(arr, low, mid, high)
    
   def merge(arr, low, mid, high):
       container = []    # 用于存储有序数字
       i, j = low, mid+1
       #相邻两个序列合并成一个新的有序序列
       #两个序列从头开始比较，小的数字先入新队，其中一个序列全部取完就结束循环
       while i <= mid and j <= high:
           if arr[i] <= arr[j]:
               container.append(arr[i])
               #成功入队后，序号加1，取下一个进行比较
               i += 1
           else:
               container.append(arr[j])
               j += 1
       #将没有比完的序列剩下的全部加入新队列后面
       if i <= mid:
           container.extend(arr[i:mid+1])
       elif j <= high:
           container.extend(arr[j:high+1])
       #将老序列原来的顺序替换成新的顺序
       arr[low:high+1] = container
   ```

8. 说出下面list1,list2,list3的输出值

    ```Python
    def extendList(val, list=[]):
     	list.append(val)
     	return list
    list1 = extendList(10)
    list2 = extendList(11,[])
    list3 = extendList('b')
    print("list1 = %s" % list1)
    print "list2 = %s" % list2)
    print "list3 = %s" % list3)
    ```

    结果

    ```
    list1 = [10, 'b']
    list2 = [11]
    list3 = [10, 'b']
    ```

<<<<<<< HEAD
    

    
=======
8. **mysql**

   1. 说几种优化方式：
      选用最合适的字段属性，
      使用连接（join）来代替子查询
      使用联合(union)来代替手动创建的临时表
      事物
      使用外键
      使用索引
      优化查询语句

   2. 视图和表的区别：

      1. 视图是已经编译好的sql语句而表不是，
      2. 视图没有实际物理记录。而表有
      3. 表是内容，视图是窗口
      4. 表占用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能用创建的语句来修改
      5. 表是内模型，视图是外模型
      6. 视图是查看数据表的一种方法，可以查询数据表中某些字段的构成的数据，只是一些sql语句的集合
      7. 从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构
      8. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。
      9. 视图的建立和删除只影响视图本身，不影响对应的基本表

      视图和表联系：视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有的数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系

9. **生成器和迭代器**

   - 迭代器是一个带状态的对象，它能在你调用next()方法的时候返回容器中的下一个值，任何实现了inter和next()（Python2中实现next()方法的对象都是迭代器，iter返回迭代器自身，next返回容器的下一个值，如果容器中没有更多的元素了，则抛出Stopiteration异常，至于它们到底是如何实现的并不重要。正是因为他是通过next()来返回迭代器中的元素，所以它是一种延迟计算方式返回对象，这种特点对于大数据量元素进行遍历时具有明显优势，他不会一次性把所有元素载入内存，而是遍历一个载入一个，大大降低了内存的占用。

   - yield的作用是发起当前执行的函数，并返回，直到调用next()，继续执行后续指令，直到再次遇到yield或者抛出StopIteration异常。上面的例子第一次运行生成器f，需要首先调用f.next()启动生成器。
     生成器的优点：代码实现更加简洁，可以提高代码的可读性。同时当然也具有迭代器的优点，大量数据遍历时内存占用少。

     ```Python
     >>> def func():
     ...   yield 
     ... 
     >>> f = func()
     >>> type(f)
     <class 'generator'>
     ```

   - 需要注意的是：生成器一定是迭代器，但是迭代器不一定是生成器，因为创建一个迭代器只需要实现**iter**和**next**()方法就可以了，并不一定要使用yield实现。生成器的唯一注意事项就是：生成器只能遍历一次。

10. **Python是如何进行内存管理**

    Python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就会创建一个引用计数，当对象不再需要时，这个对象的引用计数为0时，就被当垃圾回收了

11选择题

1. 十进制数值1.5625的二进制表示是：_____D__.

   A 101.1001    B 0.001     C 101.111  D1.1001

   小数点左侧：1 二进制还是1

   右侧为.5625

   采用乘2取整法

   .5625*2 = 1.125....................1

   .125*2 = 0.25 .....................0

   .25*2 = 0.5........................0

   .5*2 =  1.0........................1

   所以 答案为1.1001

    

2. 当进程因时间片用完而让出处理机时，该进程应该转变为___A___状态。

   ​     A等待  B就绪  C运行  D完成

   不是由于自身或外界原因成为等待状态的进程让出处理器时，它的状态就变成就绪状态。 

3.  若系统中有5台打印机，有多个进程需要使用两台，规定每一个进程一次仅允许申请一台，则至多允许__C_个进程参与竞争，而且不会发生死锁。

   A .2  B.3  C.4   D.5

   虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件。

   1 ）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

   2 ）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

   3 ）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

   4 ）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

   因此为了避免发生死锁，则不能生成此资源的环形链，**则4个进程是极限了。** 

   

4. 进程间通信方式中访问速度最快的是___E___.

      A 管道 B消息队列  C 文件  D套接字  E 共享内存 F 句柄

   常见进程间通信方式的比较：

   管道：速度慢，容量有限

   消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

   信号量：不能传递复杂消息，只能用来同步

   共享内存区：能够很容易控制容量，速度快 ，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

 

5.  下列_A___动态集合结构中查找一个元素的期望时间最短。

   A哈希表  B 链表  C 红黑树  D 二分查找树

   哈希表也就是散列表查找是常数级时间复杂度 O(1)，链表是线性级别 O(n)，红黑树和

   二分查找数都是对数及时间复杂度 O(logn)，所以结果为A。
>>>>>>> de297aca3c4670e234a8b16fb604fb851b96d7a4
